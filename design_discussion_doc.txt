Algorithm Used :

I've used Depth first search algorithm to identify reachable experts from a given start expert.

DFS Algorithm in pseudo code looks something like this
(Although I gotta say python does feel like pseudo code or plain english most of the time) :

func DFS(Graph, start_expert_node):
    mark start_expert_node as visited
    for all directed edges from start_expert_node to neighbor_expert that are in Graph.follwing(start_node) do
        if vertex neighbor_expert is not marked as visited then
            recursively call DFS(Graph, neighbor_expert)


The time complexity for depth first search algorithm is O(n + m).
Because we are visiting each node only once and
we are crossing all the edges once.
The worst case scenario is if the entire graph is traversed without repetition
which will be O(longest path length traversed) which can include all the nodes in the network.

Memory complexity : O(n) -> Worst case scenario of holding maximum n nodes in memory
if the longest path in the network has all the nodes in the network.
